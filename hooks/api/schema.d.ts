/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists channels. */
        get: operations["getChannels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/channels/{type}/{channel}/services/{sid}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a media stream of a service. */
        get: operations["getServiceStreamByChannel"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head: operations["head"];
        patch?: never;
        trace?: never;
    };
    "/channels/{type}/{channel}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a media stream of a channel. */
        get: operations["getChannelStream"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head: operations["checkChannelStream"];
        patch?: never;
        trace?: never;
    };
    "/iptv/epg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets an XMLTV document containing all TV program information. */
        get: operations["epg"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/iptv/playlist": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an M3U8 playlist containing all available services. */
        get: operations["playlist"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/iptv/xmltv": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets an XMLTV document containing all TV program information.
         * @description For compatibility with Mirakurun.
         */
        get: operations["xmltv"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/onair": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List on-air programs. */
        get: operations["getOnairPrograms"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/onair/{service_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets an on-air program of a specified service. */
        get: operations["getOnairProgram"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/programs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists TV programs.
         * @description The list contains TV programs that have ended.
         *
         *     A newer Mirakurun returns information contained in EIT[schedule]
         *     overridded by EIT[p/f] from this endpoint.  This may cause
         */
        get: operations["getPrograms"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/programs/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a TV program.
         * @description ### A special hack for EPGStation
         *
         *     If the User-Agent header string starts with "EPGStation/", this endpoint
         *     returns information contained in EIT[p/f] if it exists. Otherwise,
         *     information contained in EIT[schedule] is returned.
         *
         *     EPGStation calls this endpoint in order to update the start time and the
         *     duration of the TV program while recording.  The intention of this call is
         *     assumed that EPGStation wants to get the TV program information equivalent
         *     to EIT[p].  However, this endpoint should return information contained in
         *     EIT[schedule] basically in a web API consistency point of view.  Information
         *     contained in EIT[p/f] should be returned from other endpoints.
         *
         *     See also [/programs/{id}/stream](#/stream/getProgramStream).
         */
        get: operations["getProgram"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/programs/{id}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a media stream of a program.
         * @description ### A special hack for EPGStation
         *
         *     If the User-Agent header string starts with "EPGStation/", this endpoint
         *     creates a temporal on-air program tracker if there is no tracker defined in
         *     config.yml, which can be reused for tracking changes of the TV program
         *     metadata.
         *
         *     The temporal on-air program tracker will be stopped within 1 minute after
         *     the streaming stopped.
         *
         *     The metadata will be returned from [/programs/{id}](#/programs/getProgram).
         */
        get: operations["getProgramStream"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head: operations["checkProgramStream"];
        patch?: never;
        trace?: never;
    };
    "/recording/recorders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists recorders. */
        get: operations["getRecorders"];
        put?: never;
        /**
         * Starts recording immediately.
         * @description > **Warning**: Use `POST /api/recording/schedules` instead.
         *     > The recording will start even if the TV program has not started.
         *     > In this case, the recording will always fail.
         */
        post: operations["startRecording"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recording/recorders/{program_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a recorder. */
        get: operations["getRecorder"];
        put?: never;
        post?: never;
        /**
         * Stops recording.
         * @description Unlike `DELETE /api/recording/schedules/{program_id}`, this endpoint only
         *     stops the recording without removing the corresponding recording schedule.
         *
         *     A `recording.stopped` event will occur
         *     and `GET /api/recording/schedules/{program_id}` will return the schedule
         *     information.
         */
        delete: operations["stopRecording"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recording/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists recording schedules. */
        get: operations["getRecordingSchedules"];
        put?: never;
        /** Books a recording schedule. */
        post: operations["createRecordingSchedule"];
        /**
         * Clears recording schedules.
         * @description If a tag name is specified in the `tag` query parameter, recording schedules
         *     tagged with the specified name will be deleted.  Otherwise, all recording
         *     schedules will be deleted.
         *
         *     When deleting recording schedules by a tag, recording schedules that meet
         *     any of the following conditions won't be deleted:
         *
         *       * Recording schedules without the specified tag
         *       * Recording schedules in the `tracking` or `recording` state
         *       * Recording schedules in the `scheduled` state and will start recording
         *         soon
         */
        delete: operations["deleteRecordingSchedules"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recording/schedules/{program_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a recording schedule. */
        get: operations["getRecordingSchedule"];
        put?: never;
        post?: never;
        /** Deletes a recording schedule. */
        delete: operations["deleteRecordingSchedule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists services. */
        get: operations["getServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a service. */
        get: operations["getService"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/logo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a logo image of a service. */
        get: operations["getLogoImage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/programs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists TV programs of a service.
         * @description The list contains TV programs that have ended.
         */
        get: operations["getProgramsOfService"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a media stream of a service. */
        get: operations["getServiceStream"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head: operations["checkServiceStream"];
        patch?: never;
        trace?: never;
    };
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets current status information.
         * @description mirakc doesn't implement this endpoint and always returns an empty object.
         */
        get: operations["getStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tuners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists tuners enabled in `config.yml`. */
        get: operations["getTuners"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tuners/{index}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a tuner model. */
        get: operations["getTuner"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets version information. */
        get: operations["checkVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @enum {string} */
        ChannelType: "GR" | "BS" | "CS" | "SKY";
        /** Channel */
        MirakurunChannel: {
            channel: string;
            name: string;
            services: {
                /** Format: int64 */
                id: number;
                name: string;
                /** Format: int32 */
                networkId: number;
                /** Format: int32 */
                serviceId: number;
            }[];
            type: components["schemas"]["ChannelType"];
        };
        /** Program */
        MirakurunProgram: {
            audio?: null | {
                /** Format: int32 */
                componentType: number;
                isMain: boolean;
                langs: string[];
                /** Format: int32 */
                samplingRate: number;
            };
            audios?: {
                /** Format: int32 */
                componentType: number;
                isMain: boolean;
                langs: string[];
                /** Format: int32 */
                samplingRate: number;
            }[];
            description?: string | null;
            /** Format: int64 */
            duration: number;
            /** Format: int32 */
            eventId: number;
            extended?: Record<string, never>;
            genres?: {
                /** Format: int32 */
                lv1: number;
                /** Format: int32 */
                lv2: number;
                /** Format: int32 */
                un1: number;
                /** Format: int32 */
                un2: number;
            }[] | null;
            /** Format: int64 */
            id: number;
            isFree: boolean;
            name?: string | null;
            /** Format: int32 */
            networkId: number;
            relatedItems?: {
                /** Format: int32 */
                eventId: number;
                /** Format: int32 */
                networkId?: number | null;
                /** Format: int32 */
                serviceId: number;
                type: string;
            }[];
            series?: null | {
                /** Format: int32 */
                episode: number;
                /** Format: int64 */
                expireAt: number;
                /** Format: int32 */
                id: number;
                /** Format: int32 */
                lastEpisode: number;
                name: string;
                /** Format: int32 */
                pattern: number;
                /** Format: int32 */
                repeat: number;
            };
            /** Format: int32 */
            serviceId: number;
            /** Format: int64 */
            startAt: number;
            video?: null | {
                /** Format: int32 */
                componentType: number;
                resolution?: string | null;
                /** Format: int32 */
                streamContent: number;
                type?: string | null;
            };
        };
        /** Service */
        MirakurunService: {
            channel: {
                channel: string;
                type: components["schemas"]["ChannelType"];
            };
            hasLogoData: boolean;
            /** Format: int64 */
            id: number;
            /** Format: int32 */
            logoId?: number;
            name: string;
            /** Format: int32 */
            networkId: number;
            /** Format: int32 */
            remoteControlKeyId?: number;
            /** Format: int32 */
            serviceId: number;
            /** Format: int32 */
            type: number;
        };
        /** Tuner */
        MirakurunTuner: {
            /** @description A command to use getting a media stream from the tuner. */
            command?: string | null;
            /** @description The index of the tuner defined in `config.yml`. */
            index: number;
            /** @description Always `true`. */
            isAvailable: boolean;
            /** @description Always `false`. */
            isFault: boolean;
            /** @description `true` if the tuner is free, `false` otherwise. */
            isFree: boolean;
            /** @description Always `false`. */
            isRemote: boolean;
            /** @description `false` if the tuner is free, `true` otherwise. */
            isUsing: boolean;
            /** @description The name of the tuner defined in `config.yml`. */
            name: string;
            /**
             * Format: int32
             * @description PID of a process to run the command.
             */
            pid?: number | null;
            /** @description Channel types supported by the tuner. */
            types: components["schemas"]["ChannelType"][];
            /** @description Users of the tuner. */
            users: {
                /** @description User-Agent string. */
                agent?: string | null;
                /** @description User ID. */
                id: string;
                /**
                 * Format: int32
                 * @description Priority.
                 */
                priority: number;
            }[];
        };
        RecordingFailedReason: {
            message: string;
            /** @enum {string} */
            type: "start-recording-failed";
        } | {
            message: string;
            /** Format: int32 */
            osError?: number | null;
            /** @enum {string} */
            type: "io-error";
        } | {
            /** Format: int32 */
            exitCode: number;
            /** @enum {string} */
            type: "pipeline-error";
        } | {
            /** @enum {string} */
            type: "need-rescheduling";
        } | {
            /** @enum {string} */
            type: "schedule-expired";
        } | {
            /** @enum {string} */
            type: "removed-from-epg";
        };
        /**
         * RecordingOptions
         * @description Recording options.
         */
        RecordingOptions: {
            /** @description A relative path of a file to store recorded data. */
            contentPath: string;
            /** @description A list of post-filters to use. */
            postFilters?: string[];
            /** @description A list of pre-filters to use. */
            preFilters?: string[];
            /**
             * Format: int32
             * @description A priority of tuner usage.
             */
            priority?: number;
        };
        /**
         * RecordingScheduleState
         * @enum {string}
         */
        RecordingScheduleState: "scheduled" | "tracking" | "recording" | "rescheduling" | "finished" | "failed";
        /** @description State information of mirakc currently running. */
        Status: Record<string, never>;
        /** @description Version information of mirakc currently running. */
        Version: {
            /** @description Current version. */
            current: string;
            /** @description Same as `current`. */
            latest: string;
        };
        /**
         * OnairProgram
         * @description Metadata of TV program that is now on-air in a service.
         *
         *     The metadata is collected from EIT[p/f] sections, not from EIT[schedule]
         *     sections.
         */
        WebOnairProgram: {
            current?: null | components["schemas"]["MirakurunProgram"];
            next?: null | components["schemas"]["MirakurunProgram"];
            /**
             * Format: int64
             * @description Mirakurun service ID.
             */
            serviceId: number;
        };
        /**
         * ProcessModel
         * @description A process model constituting a pipeline.
         */
        WebProcessModel: {
            /** @description A command currently running in the pipeline. */
            command: string;
            /**
             * Format: int32
             * @description The process ID of a process running the command.
             */
            pid?: number | null;
        };
        /**
         * RecordingRecorder
         * @description A recorder model.
         */
        WebRecordingRecorder: {
            /** @description A list of process models constituting the recording pipeline. */
            pipeline: components["schemas"]["WebProcessModel"][];
            /**
             * Format: int64
             * @description A Mirakurun program ID of the TV program currently being recorded.
             */
            programId: number;
            /**
             * Format: int64
             * @description A time when the recording started.
             *
             *     It's may not be equal to the start time of the TV program.
             */
            startedAt: number;
        };
        /**
         * RecordingSchedule
         * @description A recording schedule model.
         */
        WebRecordingSchedule: {
            failedReason?: null | components["schemas"]["RecordingFailedReason"];
            /** @description Recording options. */
            options: components["schemas"]["RecordingOptions"];
            /** @description Metadata of the target TV program. */
            program: components["schemas"]["MirakurunProgram"];
            /** @description The current state of the recording schedule. */
            state: components["schemas"]["RecordingScheduleState"];
            /** @description A list of tags. */
            tags: string[];
        };
        /**
         * RecordingScheduleInput
         * @description Input data used when creating a recording schedule.
         */
        WebRecordingScheduleInput: {
            /** @description Recording options. */
            options: components["schemas"]["RecordingOptions"];
            /**
             * Format: int64
             * @description A Mirakurun program ID of the target TV program.
             */
            programId: number;
            /** @description A list of tags. */
            tags?: string[];
        };
        /**
         * TimeshiftRecord
         * @description Metadata of a timeshift record.
         */
        WebTimeshiftRecord: {
            /**
             * Format: int64
             * @description The duration of the timeshift record in milliseconds.
             */
            duration: number;
            /**
             * Format: int32
             * @description A timeshift record ID.
             */
            id: number;
            /** @description Metadata of the TV program. */
            program: components["schemas"]["MirakurunProgram"];
            /** @description `true` while recording, `false` otherwise. */
            recording: boolean;
            /**
             * Format: int64
             * @description The size of the timeshift record in bytes.
             */
            size: number;
            /**
             * Format: int64
             * @description The start time of the timeshift record in UNIX time (milliseconds).
             */
            startTime: number;
        };
        /**
         * TimeshiftRecorder
         * @description A timeshift recorder model.
         */
        WebTimeshiftRecorder: {
            /**
             * Format: int32
             * @description An ID of the record currently being recorded.
             */
            currentRecordId?: number | null;
            /**
             * Format: int64
             * @description The duration of the timeshift timeline.
             *
             *     `0` when there is no record.
             */
            duration: number;
            /**
             * Format: int64
             * @description The end time of the timeshift timeline.
             *
             *     `null` when there is no record.
             */
            endTime?: number | null;
            /** @description The timeshift recorder name defined in `config.yml`. */
            name: string;
            /**
             * @description The number of records available for playback.
             *
             *     The number will change over the recording.  For example,
             *     [/timeshift/{recorder}/records](#/timeshift::records/getTimeshiftRecords) may
             *     return different number of records from this value.
             */
            numRecords: number;
            /**
             * @description A list of process models constituting the timeshift pipeline currently
             *     running.
             */
            pipeline: components["schemas"]["WebProcessModel"][];
            /**
             * @description `true` while recording, `false` otherwise.
             *
             *     Users can still access the records even if this property returns
             *     `false`.
             */
            recording: boolean;
            /** @description Metadata of the service to be recorded. */
            service: components["schemas"]["MirakurunService"];
            /**
             * Format: int64
             * @description The start time of the timeshift timeline.
             *
             *     `null` when there is no record.
             */
            startTime?: number | null;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getChannels: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunChannel"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getServiceStreamByChannel: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Channel type */
                type: components["schemas"]["ChannelType"];
                /** @description Channel number */
                channel: string;
                /** @description Service ID (not Mirakurun Service ID) */
                sid: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    head: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Channel type */
                type: components["schemas"]["ChannelType"];
                /** @description Channel number */
                channel: string;
                /** @description Service ID (not Mirakurun Service ID) */
                sid: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChannelStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Channel type */
                type: components["schemas"]["ChannelType"];
                /** @description Channel number */
                channel: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    checkChannelStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Channel type */
                type: components["schemas"]["ChannelType"];
                /** @description Channel number */
                channel: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    epg: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/xml": string;
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    playlist: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/x-mpegURL": string;
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    xmltv: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/xml": string;
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOnairPrograms: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebOnairProgram"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOnairProgram: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun service ID */
                service_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebOnairProgram"][];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPrograms: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunProgram"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getProgram: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun program ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunProgram"][];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getProgramStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Mirakurun program ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    checkProgramStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Mirakurun program ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getRecorders: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebRecordingRecorder"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    startRecording: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebRecordingScheduleInput"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getRecorder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun program ID */
                program_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebRecordingRecorder"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    stopRecording: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun program ID */
                program_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getRecordingSchedules: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebRecordingSchedule"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createRecordingSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebRecordingScheduleInput"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebRecordingSchedule"];
                };
            };
            /** @description Bad Request */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteRecordingSchedules: {
        parameters: {
            query?: {
                /** @description Tag name */
                tag?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getRecordingSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun program ID */
                program_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebRecordingSchedule"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteRecordingSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun program ID */
                program_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getServices: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunService"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun service ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunService"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLogoImage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun service ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "image/png": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Logo Data Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getProgramsOfService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Mirakurun service ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunProgram"][];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getServiceStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Mirakurun service ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    checkServiceStream: {
        parameters: {
            query?: {
                /**
                 * @description `0` or `false` disables decoding.
                 *
                 *     The stream will be decoded by default if a decoder is specified in the
                 *     `config.yml`.
                 */
                decode?: boolean;
                /** @description A list of pre-filters to use. */
                "pre-filters"?: string[];
                /** @description A list of post-filters to use. */
                "post-filters"?: string[];
            };
            header?: {
                /** @description Priority of the tuner user */
                "X-Mirakurun-Priority"?: number | null;
            };
            path: {
                /** @description Mirakurun service ID */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    /** @description Tuner user ID */
                    "X-Mirakurun-Tuner-User-ID"?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Tuner Resource Unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                };
            };
        };
    };
    getTuners: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunTuner"][];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTuner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Tuner index */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MirakurunTuner"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    checkVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Version"];
                };
            };
        };
    };
}
