/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/channels": {
    /**
     * Lists channels.
     * @description Lists channels.
     */
    get: operations["getChannels"];
  };
  "/channels/{type}/{channel}/services/{sid}/stream": {
    /**
     * Gets a media stream of a service.
     * @description Gets a media stream of a service.
     */
    get: operations["getServiceStreamByChannel"];
    head: operations["head"];
  };
  "/channels/{type}/{channel}/stream": {
    /**
     * Gets a media stream of a channel.
     * @description Gets a media stream of a channel.
     */
    get: operations["getChannelStream"];
    head: operations["checkChannelStream"];
  };
  "/iptv/epg": {
    /**
     * Gets an XMLTV document containing all TV program information.
     * @description Gets an XMLTV document containing all TV program information.
     */
    get: operations["epg"];
  };
  "/iptv/playlist": {
    /**
     * Get an M3U8 playlist containing all available services.
     * @description Get an M3U8 playlist containing all available services.
     */
    get: operations["playlist"];
  };
  "/iptv/xmltv": {
    /**
     * Gets an XMLTV document containing all TV program information.
     * @description Gets an XMLTV document containing all TV program information.
     *
     * For compatibility with Mirakurun.
     */
    get: operations["xmltv"];
  };
  "/onair": {
    /**
     * List on-air programs.
     * @description List on-air programs.
     */
    get: operations["getOnairPrograms"];
  };
  "/onair/{service_id}": {
    /**
     * Gets an on-air program of a specified service.
     * @description Gets an on-air program of a specified service.
     */
    get: operations["getOnairProgram"];
  };
  "/programs": {
    /**
     * Lists TV programs.
     * @description Lists TV programs.
     *
     * The list contains TV programs that have ended.
     *
     * A newer Mirakurun returns information contained in EIT[schedule]
     * overridded by EIT[p/f] from this endpoint.  This may cause
     */
    get: operations["getPrograms"];
  };
  "/programs/{id}": {
    /**
     * Gets a TV program.
     * @description Gets a TV program.
     *
     * ### A special hack for EPGStation
     *
     * If the User-Agent header string starts with "EPGStation/", this endpoint
     * returns information contained in EIT[p/f] if it exists. Otherwise,
     * information contained in EIT[schedule] is returned.
     *
     * EPGStation calls this endpoint in order to update the start time and the
     * duration of the TV program while recording.  The intention of this call is
     * assumed that EPGStation wants to get the TV program information equivalent
     * to EIT[p].  However, this endpoint should return information contained in
     * EIT[schedule] basically in a web API consistency point of view.  Information
     * contained in EIT[p/f] should be returned from other endpoints.
     *
     * See also [/programs/{id}/stream](#/stream/getProgramStream).
     */
    get: operations["getProgram"];
  };
  "/programs/{id}/stream": {
    /**
     * Gets a media stream of a program.
     * @description Gets a media stream of a program.
     *
     * ### A special hack for EPGStation
     *
     * If the User-Agent header string starts with "EPGStation/", this endpoint
     * creates a temporal on-air program tracker if there is no tracker defined in
     * config.yml, which can be reused for tracking changes of the TV program
     * metadata.
     *
     * The temporal on-air program tracker will be stopped within 1 minute after
     * the streaming stopped.
     *
     * The metadata will be returned from [/programs/{id}](#/programs/getProgram).
     */
    get: operations["getProgramStream"];
    head: operations["checkProgramStream"];
  };
  "/recording/recorders": {
    /**
     * Lists recorders.
     * @description Lists recorders.
     */
    get: operations["getRecorders"];
    /**
     * Starts recording immediately.
     * @description Starts recording immediately.
     *
     * > **Warning**: Use `POST /api/recording/schedules` instead.
     * > The recording will start even if the TV program has not started.
     * > In this case, the recording will always fail.
     */
    post: operations["startRecording"];
  };
  "/recording/recorders/{program_id}": {
    /**
     * Gets a recorder.
     * @description Gets a recorder.
     */
    get: operations["getRecorder"];
    /**
     * Stops recording.
     * @description Stops recording.
     *
     * Unlike `DELETE /api/recording/schedules/{program_id}`, this endpoint only
     * stops the recording without removing the corresponding recording schedule.
     *
     * A `recording.stopped` event will occur
     * and `GET /api/recording/schedules/{program_id}` will return the schedule
     * information.
     */
    delete: operations["stopRecording"];
  };
  "/recording/schedules": {
    /**
     * Lists recording schedules.
     * @description Lists recording schedules.
     */
    get: operations["getRecordingSchedules"];
    /**
     * Books a recording schedule.
     * @description Books a recording schedule.
     */
    post: operations["createRecordingSchedule"];
    /**
     * Clears recording schedules.
     * @description Clears recording schedules.
     *
     * If a tag name is specified in the `tag` query parameter, recording schedules
     * tagged with the specified name will be deleted.  Otherwise, all recording
     * schedules will be deleted.
     *
     * When deleting recording schedules by a tag, recording schedules that meet
     * any of the following conditions won't be deleted:
     *
     * * Recording schedules without the specified tag
     * * Recording schedules in the `tracking` or `recording` state
     * * Recording schedules in the `scheduled` state and will start recording
     * soon
     */
    delete: operations["deleteRecordingSchedules"];
  };
  "/recording/schedules/{program_id}": {
    /**
     * Gets a recording schedule.
     * @description Gets a recording schedule.
     */
    get: operations["getRecordingSchedule"];
    /**
     * Deletes a recording schedule.
     * @description Deletes a recording schedule.
     */
    delete: operations["deleteRecordingSchedule"];
  };
  "/services": {
    /**
     * Lists services.
     * @description Lists services.
     */
    get: operations["getServices"];
  };
  "/services/{id}": {
    /**
     * Gets a service.
     * @description Gets a service.
     */
    get: operations["getService"];
  };
  "/services/{id}/logo": {
    /**
     * Gets a logo image of a service.
     * @description Gets a logo image of a service.
     */
    get: operations["getLogoImage"];
  };
  "/services/{id}/programs": {
    /**
     * Lists TV programs of a service.
     * @description Lists TV programs of a service.
     *
     * The list contains TV programs that have ended.
     */
    get: operations["getProgramsOfService"];
  };
  "/services/{id}/stream": {
    /**
     * Gets a media stream of a service.
     * @description Gets a media stream of a service.
     */
    get: operations["getServiceStream"];
    head: operations["checkServiceStream"];
  };
  "/status": {
    /**
     * Gets current status information.
     * @description Gets current status information.
     *
     * mirakc doesn't implement this endpoint and always returns an empty object.
     */
    get: operations["getStatus"];
  };
  "/tuners": {
    /**
     * Lists tuners enabled in `config.yml`.
     * @description Lists tuners enabled in `config.yml`.
     */
    get: operations["getTuners"];
  };
  "/tuners/{index}": {
    /**
     * Gets a tuner model.
     * @description Gets a tuner model.
     */
    get: operations["getTuner"];
  };
  "/version": {
    /**
     * Gets version information.
     * @description Gets version information.
     */
    get: operations["checkVersion"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** @enum {string} */
    ChannelType: "GR" | "BS" | "CS" | "SKY";
    /** Channel */
    MirakurunChannel: {
      channel: string;
      name: string;
      services: {
          /** Format: int64 */
          id: number;
          name: string;
          /** Format: int32 */
          networkId: number;
          /** Format: int32 */
          serviceId: number;
        }[];
      type: components["schemas"]["ChannelType"];
    };
    /** Program */
    MirakurunProgram: {
      audio?: {
        /** Format: int32 */
        componentType: number;
        isMain: boolean;
        langs: string[];
        /** Format: int32 */
        samplingRate: number;
      } | null;
      audios?: {
          /** Format: int32 */
          componentType: number;
          isMain: boolean;
          langs: string[];
          /** Format: int32 */
          samplingRate: number;
        }[];
      description?: string | null;
      /** Format: int64 */
      duration: number;
      /** Format: int32 */
      eventId: number;
      extended?: Record<string, never>;
      genres?: {
          /** Format: int32 */
          lv1: number;
          /** Format: int32 */
          lv2: number;
          /** Format: int32 */
          un1: number;
          /** Format: int32 */
          un2: number;
        }[] | null;
      /** Format: int64 */
      id: number;
      isFree: boolean;
      name?: string | null;
      /** Format: int32 */
      networkId: number;
      relatedItems?: ({
          /** Format: int32 */
          eventId: number;
          /** Format: int32 */
          networkId?: number | null;
          /** Format: int32 */
          serviceId: number;
          type: string;
        })[];
      series?: {
        /** Format: int32 */
        episode: number;
        /** Format: int64 */
        expireAt: number;
        /** Format: int32 */
        id: number;
        /** Format: int32 */
        lastEpisode: number;
        name: string;
        /** Format: int32 */
        pattern: number;
        /** Format: int32 */
        repeat: number;
      } | null;
      /** Format: int32 */
      serviceId: number;
      /** Format: int64 */
      startAt: number;
      video?: ({
        /** Format: int32 */
        componentType: number;
        resolution?: string | null;
        /** Format: int32 */
        streamContent: number;
        type?: string | null;
      }) | null;
    };
    /** Service */
    MirakurunService: {
      channel: {
        channel: string;
        type: components["schemas"]["ChannelType"];
      };
      hasLogoData: boolean;
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      logoId?: number;
      name: string;
      /** Format: int32 */
      networkId: number;
      /** Format: int32 */
      remoteControlKeyId?: number;
      /** Format: int32 */
      serviceId: number;
      /** Format: int32 */
      type: number;
    };
    /** Tuner */
    MirakurunTuner: {
      /** @description A command to use getting a media stream from the tuner. */
      command?: string | null;
      /** @description The index of the tuner defined in `config.yml`. */
      index: number;
      /** @description Always `true`. */
      isAvailable: boolean;
      /** @description Always `false`. */
      isFault: boolean;
      /** @description `true` if the tuner is free, `false` otherwise. */
      isFree: boolean;
      /** @description Always `false`. */
      isRemote: boolean;
      /** @description `false` if the tuner is free, `true` otherwise. */
      isUsing: boolean;
      /** @description The name of the tuner defined in `config.yml`. */
      name: string;
      /**
       * Format: int32
       * @description PID of a process to run the command.
       */
      pid?: number | null;
      /** @description Channel types supported by the tuner. */
      types: components["schemas"]["ChannelType"][];
      /** @description Users of the tuner. */
      users: ({
          /** @description User-Agent string. */
          agent?: string | null;
          /** @description User ID. */
          id: string;
          /**
           * Format: int32
           * @description Priority.
           */
          priority: number;
        })[];
    };
    RecordingFailedReason: {
      message: string;
      /** @enum {string} */
      type: "start-recording-failed";
    } | ({
      message: string;
      /** Format: int32 */
      osError?: number | null;
      /** @enum {string} */
      type: "io-error";
    }) | {
      /** Format: int32 */
      exitCode: number;
      /** @enum {string} */
      type: "pipeline-error";
    } | {
      /** @enum {string} */
      type: "need-rescheduling";
    } | {
      /** @enum {string} */
      type: "schedule-expired";
    } | {
      /** @enum {string} */
      type: "removed-from-epg";
    };
    /**
     * RecordingOptions
     * @description Recording options.
     */
    RecordingOptions: {
      /** @description A relative path of a file to store recorded data. */
      contentPath: string;
      /** @description A list of post-filters to use. */
      postFilters?: string[];
      /** @description A list of pre-filters to use. */
      preFilters?: string[];
      /**
       * Format: int32
       * @description A priority of tuner usage.
       */
      priority?: number;
    };
    /**
     * RecordingScheduleState
     * @enum {string}
     */
    RecordingScheduleState: "scheduled" | "tracking" | "recording" | "rescheduling" | "finished" | "failed";
    /** @description State information of mirakc currently running. */
    Status: Record<string, never>;
    /** @description Version information of mirakc currently running. */
    Version: {
      /** @description Current version. */
      current: string;
      /** @description Same as `current`. */
      latest: string;
    };
    /**
     * OnairProgram
     * @description Metadata of TV program that is now on-air in a service.
     *
     * The metadata is collected from EIT[p/f] sections, not from EIT[schedule]
     * sections.
     */
    WebOnairProgram: {
      current?: components["schemas"]["MirakurunProgram"] | null;
      next?: components["schemas"]["MirakurunProgram"] | null;
      /**
       * Format: int64
       * @description Mirakurun service ID.
       */
      serviceId: number;
    };
    /**
     * ProcessModel
     * @description A process model constituting a pipeline.
     */
    WebProcessModel: {
      /** @description A command currently running in the pipeline. */
      command: string;
      /**
       * Format: int32
       * @description The process ID of a process running the command.
       */
      pid?: number | null;
    };
    /**
     * RecordingRecorder
     * @description A recorder model.
     */
    WebRecordingRecorder: {
      /** @description A list of process models constituting the recording pipeline. */
      pipeline: components["schemas"]["WebProcessModel"][];
      /**
       * Format: int64
       * @description A Mirakurun program ID of the TV program currently being recorded.
       */
      programId: number;
      /**
       * Format: int64
       * @description A time when the recording started.
       *
       * It's may not be equal to the start time of the TV program.
       */
      startedAt: number;
    };
    /**
     * RecordingSchedule
     * @description A recording schedule model.
     */
    WebRecordingSchedule: {
      failedReason?: ({
        type: "WebRecordingSchedule";
      } & Omit<components["schemas"]["RecordingFailedReason"], "type">) | null;
      options: components["schemas"]["RecordingOptions"];
      program: components["schemas"]["MirakurunProgram"];
      state: components["schemas"]["RecordingScheduleState"];
      /** @description A list of tags. */
      tags: string[];
    };
    /**
     * RecordingScheduleInput
     * @description Input data used when creating a recording schedule.
     */
    WebRecordingScheduleInput: {
      options: components["schemas"]["RecordingOptions"];
      /**
       * Format: int64
       * @description A Mirakurun program ID of the target TV program.
       */
      programId: number;
      /** @description A list of tags. */
      tags?: string[];
    };
    /**
     * TimeshiftRecord
     * @description Metadata of a timeshift record.
     */
    WebTimeshiftRecord: {
      /**
       * Format: int64
       * @description The duration of the timeshift record in milliseconds.
       */
      duration: number;
      /**
       * Format: int32
       * @description A timeshift record ID.
       */
      id: number;
      program: components["schemas"]["MirakurunProgram"];
      /** @description `true` while recording, `false` otherwise. */
      recording: boolean;
      /**
       * Format: int64
       * @description The size of the timeshift record in bytes.
       */
      size: number;
      /**
       * Format: int64
       * @description The start time of the timeshift record in UNIX time (milliseconds).
       */
      startTime: number;
    };
    /**
     * TimeshiftRecorder
     * @description A timeshift recorder model.
     */
    WebTimeshiftRecorder: {
      /**
       * Format: int32
       * @description An ID of the record currently being recorded.
       */
      currentRecordId?: number | null;
      /**
       * Format: int64
       * @description The duration of the timeshift timeline.
       *
       * `0` when there is no record.
       */
      duration: number;
      /**
       * Format: int64
       * @description The end time of the timeshift timeline.
       *
       * `null` when there is no record.
       */
      endTime?: number | null;
      /** @description The timeshift recorder name defined in `config.yml`. */
      name: string;
      /**
       * @description A list of process models constituting the timeshift pipeline currently
       * running.
       */
      pipeline: components["schemas"]["WebProcessModel"][];
      /**
       * @description `true` while recording, `false` otherwise.
       *
       * Users can still access the records even if this property returns
       * `false`.
       */
      recording: boolean;
      service: components["schemas"]["MirakurunService"];
      /**
       * Format: int64
       * @description The start time of the timeshift timeline.
       *
       * `null` when there is no record.
       */
      startTime?: number | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Lists channels.
   * @description Lists channels.
   */
  getChannels: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunChannel"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a media stream of a service.
   * @description Gets a media stream of a service.
   */
  getServiceStreamByChannel: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Channel type */
        type: components["schemas"]["ChannelType"];
        /** @description Channel number */
        channel: string;
        /** @description Service ID (not Mirakurun Service ID) */
        sid: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  head: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Channel type */
        type: components["schemas"]["ChannelType"];
        /** @description Channel number */
        channel: string;
        /** @description Service ID (not Mirakurun Service ID) */
        sid: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  /**
   * Gets a media stream of a channel.
   * @description Gets a media stream of a channel.
   */
  getChannelStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Channel type */
        type: components["schemas"]["ChannelType"];
        /** @description Channel number */
        channel: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  checkChannelStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Channel type */
        type: components["schemas"]["ChannelType"];
        /** @description Channel number */
        channel: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  /**
   * Gets an XMLTV document containing all TV program information.
   * @description Gets an XMLTV document containing all TV program information.
   */
  epg: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/xml": string;
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get an M3U8 playlist containing all available services.
   * @description Get an M3U8 playlist containing all available services.
   */
  playlist: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets an XMLTV document containing all TV program information.
   * @description Gets an XMLTV document containing all TV program information.
   *
   * For compatibility with Mirakurun.
   */
  xmltv: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/xml": string;
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * List on-air programs.
   * @description List on-air programs.
   */
  getOnairPrograms: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebOnairProgram"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets an on-air program of a specified service.
   * @description Gets an on-air program of a specified service.
   */
  getOnairProgram: {
    parameters: {
      path: {
        /** @description Mirakurun service ID */
        service_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebOnairProgram"][];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Lists TV programs.
   * @description Lists TV programs.
   *
   * The list contains TV programs that have ended.
   *
   * A newer Mirakurun returns information contained in EIT[schedule]
   * overridded by EIT[p/f] from this endpoint.  This may cause
   */
  getPrograms: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunProgram"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a TV program.
   * @description Gets a TV program.
   *
   * ### A special hack for EPGStation
   *
   * If the User-Agent header string starts with "EPGStation/", this endpoint
   * returns information contained in EIT[p/f] if it exists. Otherwise,
   * information contained in EIT[schedule] is returned.
   *
   * EPGStation calls this endpoint in order to update the start time and the
   * duration of the TV program while recording.  The intention of this call is
   * assumed that EPGStation wants to get the TV program information equivalent
   * to EIT[p].  However, this endpoint should return information contained in
   * EIT[schedule] basically in a web API consistency point of view.  Information
   * contained in EIT[p/f] should be returned from other endpoints.
   *
   * See also [/programs/{id}/stream](#/stream/getProgramStream).
   */
  getProgram: {
    parameters: {
      path: {
        /** @description Mirakurun program ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunProgram"][];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a media stream of a program.
   * @description Gets a media stream of a program.
   *
   * ### A special hack for EPGStation
   *
   * If the User-Agent header string starts with "EPGStation/", this endpoint
   * creates a temporal on-air program tracker if there is no tracker defined in
   * config.yml, which can be reused for tracking changes of the TV program
   * metadata.
   *
   * The temporal on-air program tracker will be stopped within 1 minute after
   * the streaming stopped.
   *
   * The metadata will be returned from [/programs/{id}](#/programs/getProgram).
   */
  getProgramStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Mirakurun program ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  checkProgramStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Mirakurun program ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  /**
   * Lists recorders.
   * @description Lists recorders.
   */
  getRecorders: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebRecordingRecorder"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Starts recording immediately.
   * @description Starts recording immediately.
   *
   * > **Warning**: Use `POST /api/recording/schedules` instead.
   * > The recording will start even if the TV program has not started.
   * > In this case, the recording will always fail.
   */
  startRecording: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebRecordingScheduleInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: never;
      };
      /** @description Bad Request */
      401: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a recorder.
   * @description Gets a recorder.
   */
  getRecorder: {
    parameters: {
      path: {
        /** @description Mirakurun program ID */
        program_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebRecordingRecorder"];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Stops recording.
   * @description Stops recording.
   *
   * Unlike `DELETE /api/recording/schedules/{program_id}`, this endpoint only
   * stops the recording without removing the corresponding recording schedule.
   *
   * A `recording.stopped` event will occur
   * and `GET /api/recording/schedules/{program_id}` will return the schedule
   * information.
   */
  stopRecording: {
    parameters: {
      path: {
        /** @description Mirakurun program ID */
        program_id: number;
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: never;
      };
      /** @description Bad Request */
      401: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Lists recording schedules.
   * @description Lists recording schedules.
   */
  getRecordingSchedules: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebRecordingSchedule"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Books a recording schedule.
   * @description Books a recording schedule.
   */
  createRecordingSchedule: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebRecordingScheduleInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["WebRecordingSchedule"];
        };
      };
      /** @description Bad Request */
      401: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Clears recording schedules.
   * @description Clears recording schedules.
   *
   * If a tag name is specified in the `tag` query parameter, recording schedules
   * tagged with the specified name will be deleted.  Otherwise, all recording
   * schedules will be deleted.
   *
   * When deleting recording schedules by a tag, recording schedules that meet
   * any of the following conditions won't be deleted:
   *
   * * Recording schedules without the specified tag
   * * Recording schedules in the `tracking` or `recording` state
   * * Recording schedules in the `scheduled` state and will start recording
   * soon
   */
  deleteRecordingSchedules: {
    parameters: {
      query?: {
        /** @description Tag name */
        tag?: string | null;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a recording schedule.
   * @description Gets a recording schedule.
   */
  getRecordingSchedule: {
    parameters: {
      path: {
        /** @description Mirakurun program ID */
        program_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebRecordingSchedule"];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Deletes a recording schedule.
   * @description Deletes a recording schedule.
   */
  deleteRecordingSchedule: {
    parameters: {
      path: {
        /** @description Mirakurun program ID */
        program_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description Bad Request */
      401: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Lists services.
   * @description Lists services.
   */
  getServices: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunService"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a service.
   * @description Gets a service.
   */
  getService: {
    parameters: {
      path: {
        /** @description Mirakurun service ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunService"];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a logo image of a service.
   * @description Gets a logo image of a service.
   */
  getLogoImage: {
    parameters: {
      path: {
        /** @description Mirakurun service ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Logo Data Unavailable */
      503: {
        content: never;
      };
    };
  };
  /**
   * Lists TV programs of a service.
   * @description Lists TV programs of a service.
   *
   * The list contains TV programs that have ended.
   */
  getProgramsOfService: {
    parameters: {
      path: {
        /** @description Mirakurun service ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunProgram"][];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a media stream of a service.
   * @description Gets a media stream of a service.
   */
  getServiceStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Mirakurun service ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  checkServiceStream: {
    parameters: {
      query?: {
        /**
         * @description `0` or `false` disables decoding.
         *
         * The stream will be decoded by default if a decoder is specified in the
         * `config.yml`.
         */
        decode?: boolean;
        /** @description A list of pre-filters to use. */
        "pre-filters"?: string[];
        /** @description A list of post-filters to use. */
        "post-filters"?: string[];
      };
      header?: {
        /** @description Priority of the tuner user */
        "X-Mirakurun-Priority"?: number | null;
      };
      path: {
        /** @description Mirakurun service ID */
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          /** @description Tuner user ID */
          "X-Mirakurun-Tuner-User-ID"?: string;
        };
        content: never;
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
      /** @description Tuner Resource Unavailable */
      503: {
        content: never;
      };
    };
  };
  /**
   * Gets current status information.
   * @description Gets current status information.
   *
   * mirakc doesn't implement this endpoint and always returns an empty object.
   */
  getStatus: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Status"];
        };
      };
    };
  };
  /**
   * Lists tuners enabled in `config.yml`.
   * @description Lists tuners enabled in `config.yml`.
   */
  getTuners: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunTuner"][];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets a tuner model.
   * @description Gets a tuner model.
   */
  getTuner: {
    parameters: {
      path: {
        /** @description Tuner index */
        index: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["MirakurunTuner"];
        };
      };
      /** @description Not Found */
      404: {
        content: never;
      };
      /** @description Internal Server Error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Gets version information.
   * @description Gets version information.
   */
  checkVersion: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Version"];
        };
      };
    };
  };
}
